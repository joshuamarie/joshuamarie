{
  "hash": "824b05126cf00cb8a2ac134ae1f30895",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Ways to load / attach packages in R'\nsubtitle: 'Worst to best solution'\ndate: \"2025-11-10\"\nimage: \"image.png\"\ncategories: [R, packages]\nformat:\n    html:\n        toc: true\n        toc-float: true\n        toc-depth: 3\n        number-sections: true\n        code-fold: false\n        code-tools: false\n        theme: default\n        highlight-style: tango\n        fig-width: 10\n        fig-height: 6\n        fig-cap-location: bottom\nexecute:\n    echo: true\n    message: false\n    warning: false\n    fig-align: center\n    fig-width: 10\n    fig-height: 6\ncode-annotations: hover\n---\n\n\n\nIsn't it great that R has more than 1 solution to load packages? \n\n![](image.png)\n\nIn this post, I will try enumerate the different ways to load packages in R, and discuss their pros and cons. I will also rank them from worst to best solution in practices.\n\n# Different ways to load / attach packages in R\n\nI sorted the different ways to load packages in R from worst to best solution in practices. This may be subjective, but I will try to justify my ranking based on the principles of good programming practices.\n\n## Worst: Using **require()**\n\nI'll be making a hot take here that sounds controversial, but this solution is the worst thing ever existed in R to attach the packages. \n\nThis function returns a Boolean value: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(pkg) |> \n    suppressMessages() |> \n    suppressWarnings() |> \n    print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\nIt returns `TRUE` if the package is successfully loaded and `FALSE` otherwise. \n\nAnd should only be applicable inside functions to check if a package is available. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_package = function() {\n    if (require(pkg, quietly = TRUE)) {\n        print(\"Package loaded successfully\")\n    } else {\n        print(\"Package not available\")\n    }\n}\ncheck_package()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Package not available\"\n```\n\n\n:::\n:::\n\n\n\nUsing `require()` at the top level of your script can lead to silent failures. If the package isn't installed, your code continues executing, leading to cryptic errors later when you try to use functions from the missing package. \n\nSeriously, this is just `library()` where you can place it at the top level of your script, but add another extra steps. \n\n## The classic **library()**\n\nSuch a classic function, isn't it? After all, this is the most used function to attach R package namespace. It is a standard practice that most R users use, and it is safe: It will throw an error if `pkg` is not installed. This function is traditional and simple:\n\n``` r\nlibrary(pkg)\n```\n\nThat's it, right? I hope it was that simple, but it has some serious downsides: \n\ni.  It attaches the entire package namespace to the *search path*, \nii.  It can lead to namespace clash, particularly if multiple packages have functions with the same name. This can make debugging difficult and lead to unexpected behaviors in your code.\niii.  It makes the imports unclear which functions come from which packages\niv.  All exported functions are available, even if you only need one or two\n\nTo detach the attached package namespace in the search path, use `detach()` function with `package : ` keyword:\n\n``` r\ndetach(package : pkg)\n```\n\n::: callout-warning\nBe minded that `library()` function still potentially silently fails, even though it will throw an error, unlike `require()` where silent fails are always prominent. \n:::\n\n## The pro boxer: **{pacman}**\n\nThe `{pacman}` package tries to streamline package management with functions like `p_load()`.\n\nDo you know this?\n\n``` r\nif (!require(pkg)) {\n    install.packages(\"pkg\")\n    library(pkg)\n}\n```\n\nWith `pacman::p_load()`:\n\n``` r\npacman::p_load(pkg)\n```\n\nYou can do the same as above, except you can do this for multiple packages. \n\nHere's how:\n\n``` r\npacman::p_load(pkg1, pkg2, pkg3)\n```\n\nThis is definitely not the worst solution ever made, but my take is that it still doesn't solve the problem I had: Lack of granular imports and importing the packages WITHOUT attaching the entire namespace. \n\nWhat I don't like about this package and why I don't recommend this\n\n- Violates the [single responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle), where in `{pacman}`'s case, mixing installation and loading. \n- Installation should be a deliberate, one-time setup step, not hidden in your analysis code\n- Can lead to unexpected behavior in production environments\n- Makes code less portable and reproducible\n- Adds an external dependency just for loading packages\n\n## The new **base::use()** function (v4.4.0+) {#base-use}\n\nThis function is available in R version 4.4.0 and above. It allows you to load packages in a way that minimizes namespace conflicts by only attaching the functions you explicitly use. Take note that `base::use()` is a short case of `library()`, a simple wrapper, where it keeps `include.only` and set: \n\n1.  `lib.loc` to `NULL`\n2.  `character.only` to `TRUE`\n3.  `logical.return` to `TRUE`\n4.  `attach.required` to `FALSE`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse('pkg', c('obj1', 'fun1'))\n```\n:::\n\n\n\nThis is still `library()`, but granular imports are explicit. However, another problem occurs: Since it is just a simple wrapper of `library()`, therefore the import still goes to the search path. \n\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_data = function(.data) {\n    use('dplyr', 'summarise')\n    use('tidyr', 'pivot_longer')\n    \n    summarise(\n        .data, across(\n            where(is.numeric), \n            \\(col) mean(col, na.rm = TRUE)\n        )\n    ) |> \n        pivot_longer(\n            cols = where(is.numeric), \n            names_to = \"Variable\", \n            values_to = \"Ave\"\n        )\n}\n\nmean_data(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  Variable       Ave\n  <chr>        <dbl>\n1 Sepal.Length  5.84\n2 Sepal.Width   3.06\n3 Petal.Length  3.76\n4 Petal.Width   1.20\n```\n\n\n:::\n:::\n\n\n\nAfter I execute `mean_data(iris)`, the imports are accessible *anywhere*. And `base::use()` is still broken even in the latest R versions.\n\n::: callout-note\nThis is noted by R core team:\n\n> This functionality is still experimental: interfaces may change in future versions.\n\n:::\n\n## **library()** and **{conflicted}** package combo\n\nHow about forcing the search path to select / deselect the imports? Introducing `{conflicted}` package. In this approach, I combine traditional `library()` with the `{conflicted}` package to explicitly handle namespace conflicts.\n\nHow good? For example, I prefer using `dplyr::filter()` over `stats::filter()`, but a bit later on, I want to use `stats::filter()` since I want to run time series. The `conflicted::conflict_prefer()` handles which you want to declare \"winners\" of conflicts.\n\nI'll make a scenario: \n\ni.  I have no use with `stats::filter()` because I only want to keep the data frame based on the condition using `dplyr::filter()`. Here, I declare `dplyr::filter()` as \"winner\" of the conflict: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nconflicted::conflict_prefer('filter', 'dplyr', 'stats')\nfilter(mtcars, cyl == 8)\n```\n:::\n\n\n\nii.  Then, I stopped using `dplyr::filter()` because I want to perform time series modelling with linear filtering using `stats::filter()`. Re-state `stats::filter()` as the \"winner\" of the conflict:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflicted::conflict_prefer('filter', 'stats', 'dplyr')\nfilter(1:10, rep(1, 3))\n```\n:::\n\n\n\nIn my standard, this is actually good, but still not enough because it never allows granular imports and import aliasing, and besides, I've had better. \n\n## Tedious but Explicit: The **::** Operator\n\nBefore packages like `{box}` and `{import}` introduced alternative import systems to R, the `::` operator was (and still is) R's built-in way to explicitly reference functions from specific namespaces without loading entire packages.\n\nThe `::` operator is the most explicit base R solution for calling package functions. It's part of R's namespace system and requires no external dependencies - just base R.\n\nHere's how:  \n\n-   The syntax is `package::function()`, which tells R exactly which package to pull the function from without attaching that package to your search path.\n\nMost of us using R are definitely using this (I am reusing an example from [base::use](#base-use)): \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_data = function(.data) {\n    dplyr::summarise(\n        .data, across(\n            where(is.numeric), \n            \\(col) mean(col, na.rm = TRUE)\n        )\n    ) |> \n        tidyr::pivot_longer(\n            cols = where(is.numeric), \n            names_to = \"Variable\", \n            values_to = \"Ave\"\n        )\n}\n\nmean_data(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  Variable       Ave\n  <chr>        <dbl>\n1 Sepal.Length  5.84\n2 Sepal.Width   3.06\n3 Petal.Length  3.76\n4 Petal.Width   1.20\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note title=\"Notice\"}\n> Noticed that I don't call `dplyr::` for `across()` and `where()`? I have a [blog](https://joshuamarie.github.io/joshuamarie/posts/04-tidyselect-helpers/) talking about this. \n\n:::\n\nThis is great, compared to the previous solutions, no external packages needed and works mostly in any R version. The problem is this is way too verbose and repetitive, especially with many function calls:\n\n``` r\nggplot2::ggplot(data, ggplot2::aes(date, y)) +\n    ggplot2::geom_point() + \n    ggplot2::geom_line() + \n    ggplot2::theme_minimal() + \n    ggplot2::labs(\n        x = \"Date (by month)\",\n        y = \"Value (in dollars)\", \n        title = \"Monthly Value in Dollar\"\n    )\n```\n\nBeing typing-intensive is why I called this solution \"tedious\". \n\n## Second to best: **{import}** package\n\nThis package is made before `{box}`. So, before `{box}`, the `{import}` package is arrived to fix `library()`'s most egregious issues. Created by Stefan Milton Bache (of pipe fame), it brings selective imports to R without requiring a complete paradigm shift.\n\n::: panel-tabset\n\n### First Example\n\n``` r\nimport::from(\n    dplyr, \n    select, rename, keep_when = filter, mutate, summarise, n\n)\nimport::from(tidyr, long = pivot_longer, wide = pivot_wider, drop_na)\nimport::from(ggplot2, diamonds, cut_width)\n\ndiamonds |> \n    keep_when(\n        cut %in% c(\"Ideal\", \"Premium\"), \n        carat > 1\n    ) |> \n    drop_na() |> \n    mutate(\n        price_per_carat = price / carat,\n        size_category = cut_width(carat, 0.5)\n    ) |> \n    select(carat, cut, color, price, price_per_carat, size_category) |> \n    wide(\n        names_from = cut,\n        values_from = price_per_carat,\n        values_fn = median\n    ) |> \n    summarise(\n        across(c(Ideal, Premium), \\(col) mean(col, na.rm = TRUE)),\n        n = n()\n    )\n```\n\n### Symbol binding\n\n``` r\nimport::from(dplyr, select, filter, mutate, summarise, n, relocate)\nimport::from(magrittr, `%>%`)  # <1>\nimport::from(tidyr, long = pivot_longer, wide = pivot_wider, drop_na)\n\nmtcars %>% \n    filter(cyl == 6) %>% \n    mutate(\n        hp_per_cyl = hp / cyl,\n        efficiency = mpg / disp\n    ) %>% \n    select(mpg, disp, hp, hp_per_cyl, efficiency, everything()) %>% \n    summarise(\n        across(\n            c(mpg, hp_per_cyl, efficiency), list(mu = mean, sigma = sd), \n            .names = \"{.col}..{.fn}\"\n        ),\n        n = n()\n    ) %>% \n    long(\n        cols = contains(c(\"mu\", \"sigma\")), \n        names_sep = \"\\\\..\", \n        names_to = c(\"Variable\", \"Stat\"), \n        values_to = \"Est\"\n    ) %>% \n    wide(\n        names_from = Stat, \n        values_from = Est\n    ) %>% \n    relocate(n, .after = last_col()) %>%\n    mutate(\n        se = sigma / sqrt(n), \n        cv = sigma / mu\n    )\n```\n\n1. This is how you import the pipe operator from magrittr\n\n:::\n\nThere's still some problem. Even though `{import}` provide necessities that solves my problem in R's import system:\n\n1.  It has no unifying solution to attach the imports in the current environment. In fact, `{import}` functions still attach imported functions to the parent environment (usually global). What I mean is that they're not truly scoped to a module or function. Thus, the use of `import::here()`: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(iris, {\n    import::here(stats, corr = cor)\n    \n    corr(Sepal.Length, Petal.Length)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8717538\n```\n\n\n:::\n:::\n\n\n\nThis is better than loading entire packages, but not as clean as lexical scoping.\n\n2.  The package was designed primarily for **CRAN packages**. File-based modules feel like an afterthought rather than a first-class feature. \n\n3.  It lacks support for **nested module hierarchies**. You can import from files with this package, but you can't organize modules into sophisticated directory structures with their own internal dependencies.\n\n4.  Unlike `{box}`, you can't import the whole package WITHOUT attaching the names. \n\n## The ergonomically superior **{box}** package\n\n![](gordon-ramsay-finally.gif)\n\nFinally, some good food. In 2021, this package introduced a new module system for R by Konrad Rudolph. It allows you to load packages and their functions in a modular way, similar to how modules work in other programming languages like Python or JavaScript. This approach helps to avoid namespace clashes and makes it clear which functions are being used from which packages.\n\nHere's what it looks like to use `{box}` to load a package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox::use(\n    dplyr[keep_when = filter, select, mutate],\n    ggplot2[ggplot, aes, geom_point]\n)\n```\n:::\n\n\n\nYou are also allowed to reuse exported namespace from an R script or a folder as a module. Let us assume that `{./my_module}` is a folder in your root directory, where it contains multiple R scripts exporting functions, and `{./utils}` is a single R script exporting utility functions. You can load them as modules like this:\n\n``` r\nbox::use(\n    ./my_module,\n    ./path/to/utils\n)\n```\n\nWith `{box}`, you can create modules that encapsulate your code and its dependencies, another revolutionary and W move in R community. This package is making my life easier in managing and reuse code across different projects. This approach aligns well with modern programming practices and helps to keep your codebase clean and maintainable. In fact, I made a [book](https://joshuamarie.github.io/modules-in-r/) dedicated on module system with this package. \n\n# Conclusion\n\nWhile there are multiple ways to load packages in R, not all methods are created equal. The choice of method can significantly impact the readability, maintainability, and reliability of your code. I recommend using the `{box}` package for its modular approach and ability to avoid namespace clashes, making it a superior choice for loading packages in R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}